# GRADE 1. ЭТАП 1. Задание 5.
# Работа с объектами типа "дата"
import datetime

# Библиотека для раскрашивания консоли
from colorama import init, Fore, Back, Style

# Авто сброс покраски строчек (сброс заданного цвета строчки для каждой команды print)
init(autoreset=True)

# Укрощение (извращение) colorama's цветов, дико извиняюсь
r = Fore.RED
m = Fore.MAGENTA
c = Fore.CYAN
g = Fore.GREEN
lg = Fore.LIGHTGREEN_EX
y = Fore.YELLOW


# ФУНКЦИЯ ПОСТ-ПАУЗЫ
def console_pause():
    """Создаёт поле ввода в консоли.
    Представляет собой разделитель действий во время выполнения программы"""
    command_pause = input(g + '\nУспешно. Для продолжения работы нажмите клавишу ENTER...')


# ФУНКЦИЯ ПРОВЕРКИ ПОЛЬЗОВАТЕЛЬСКОГО ВВОДА
def correct_input(a):
    """Обрабатывает пользовательский ввод на наличие только пробелов либо пустого ввода

    Принимает: введенное пользователем значение
    Возвращает: True или False"""
    return a.isspace() == False and a != ''


# ФУНКЦИЯ ДОБАВЛЕНИЯ ИМЕНИ ПОЛЬЗОВАТЕЛЯ
def add_name_loop():
    """Представляет собой цикл добавления имени пользователя с обработкой ввода

    Требует для работы: словарь add_note_dict;
    Содержит: ключ словаря 'Имя пользователя'
    """
    while True:
        add_note_dict['Имя пользователя'] = input(m + '\nВведите имя: ')
        # Проверка пользовательского ввода при помощи функции correct_input
        if correct_input(add_note_dict['Имя пользователя']) == True:
            break
        else:
            print(r + '(!) Имя пользователя не может быть пустым. Пожалуйста, повторите ввод')
            continue


# ФУНКЦИЯ ДОБАВЛЕНИЯ ТЕМ
def add_titles_loop():
    """Представляет собой цикл добавления нескольких тем с обработкой ввода

    Требует для работы: словарь add_note_dict;
    Содержит: ключ словаря 'Темы'.
    Механизм: запрашивает бесконечный цикл ввода тем с проверкой на уникальность.
    Не позволяет вводить только пробелы. Завершает цикл при пустом вводе
    """
    print(c + 'Программа запрашивает несколько уникальных заголовков,'
              ' для прерывания операции оставьте поле пустым.')
    add_note_dict['Темы'] = []
    title_ticker = 1            # Переменная счётчик введённых заголовков
    while True:
        title = input(m + f'Введите тему заметки {title_ticker}: ')
            # Условие только пробелы или пустой ввод
        if title != '':
            if title.isspace() == True:
                print(r + '(!) Тема заметки не может содержать только пробелы')
            else:
                    # Условие поиска совпадений
                if add_note_dict['Темы'].count(title):
                    print(r + '(!)Такая тема заметки уже существует. '
                              'Пожалуйста, введите уникальную тему или завершите ввод.')
                    continue
                    # Добавление заголовков в список ключа
                else:
                    add_note_dict['Темы'].append(title)
                    title_ticker = title_ticker + 1
            # Условие выхода из цикла, если список содержит хотя бы одну тему, а ввод пуст
        elif title == '' and len(add_note_dict['Темы']) > 0:
            title_ticker = 1
            break
        else:
            print(r + '(!) Должен быть хотя бы он заголовок')


# ФУНКЦИЯ ДОБАВЛЕНИЯ ОПИСАНИЯ ЗАМЕТКИ
def add_description_loop():
    """Представляет собой цикл добавления описания с обработкой ввода

    Требует для работы: словарь add_note_dict;
    Содержит: ключ словаря 'Описание'
    """
    while True:
        add_note_dict['Описание'] = input(m + 'Введите описание: ')
        if correct_input(add_note_dict['Описание']) == True:
            break
        else:
            print(r + '(!) Описание не может быть пустым. Пожалуйста, повторите ввод')
            continue


# ФУНКЦИЯ ВЫБОРА ИЛИ РЕДАКТИРОВАНИЯ СТАТУСА
def add_status_loop():
    """Функция выбора статуса или добавление пользовательского варианта статуса.

    Требует для работы: словарь add_note_dict;
    Содержит: ключ словаря 'Статус'
    Механизм: вывод меню команд, содержащих выбор для пользователя где:
    1, 2 и 3 команды добавляют в ключ предустановленный статус.
    Команда 4 позволяет получить кастомный статус от пользователя с проверкой ввода
    при помощи функции correct_input
    """
    while True:
        print(c + 'Выберите статус заметки. Для ввода пользовательского статуса используйте команду 4: '
                  '\n○ Активна          — 1; '
                  '\n○ Отложена         — 2; '
                  '\n○ Выполнена        — 3; '
                  '\n○ Ввести статус    — 4.')
        status_command = input(m + 'Введите команду: ') # пользовательский ввод
        #_____КОМАНДА 1_________добавление статуса "Активна"
        if status_command == '1':
            add_note_dict['Статус'] = 'Активна'
            break
        # _____КОМАНДА 2_________добавление статуса "Отложена"
        elif status_command == '2':
            add_note_dict['Статус'] = 'Отложена'
            break
        # _____КОМАНДА 3_________добавление статуса "Выполнена"
        elif status_command == '3':
            add_note_dict['Статус'] = 'Выполнена'
            break
        # _____КОМАНДА 4_________добавление пользовательского статуса
        elif status_command == '4':
            add_note_dict['Статус'] = input(m + 'Введите пользовательский статус: ')
            if correct_input(add_note_dict['Статус']) == True:
                break
            else:
                print(r + '(!) Статус не может быть пустым! Попробуйте заново.')
                continue
        else:
            print(r + '(!) Такой команды не существует! Пожалуйста, введите доступную команду.')
            continue


# ФУНКЦИЯ СУММОНА И ВВОДА ДАТ
def date_mechanism_loop():
    """Функция получения текущей и пользовательской даты с единым (заданным) форматом.

    Требует для работы: библиотеку import datetime, словарь add_note_dict
    Содержит: ключ словаря 'Создана' и ключ словаря 'Дата завершения'
    Механизм: механизм получения текущей даты заключается в строковом преобразовании текущей даты,
    полученной при помощи now() и помещения ее в ключ 'Создана'.
    Получение даты завершения производится при помощи пользовательского ввода с подсказкой формата и
    обработкой ошибок (перевод из строки в объект date с заданным форматом, а затем снова в str
    для импорта в ключ) и исключений
    """
    # Получение текущей даты
    add_note_dict['Создана'] = datetime.datetime.strftime(datetime.datetime.now(), "%d-%m-%Y")
    # Получение даты завершения заметки и проверка пользовательского ввода
    while True:
        try:
            temp_issue_date = datetime.datetime.strptime(
                input(m + 'Введите дату завершения (день-месяц-год): '), "%d-%m-%Y")
            issue_date = datetime.datetime.strftime(temp_issue_date, "%d-%m-%Y")
            add_note_dict['Дата завершения'] = issue_date
            break
        except ValueError:
            print(r + '(!) Пожалуйста, соблюдайте формат даты **день-месяц-год**')
            continue


# ФУНКЦИЯ ОТРИСОВКИ ЗАМЕТОК
def print_notes_loop():
    """Предназначения для читаемого вывода списка заметок и срока до дедлайна.

    Требует для работы: библиотеку import datetime и colorama;
    перебор списка словарей (обязательно с функцией enumerate), где каждый словарь помещается в переменную note;
    ключи 'Имя пользователя', 'Темы', 'Описание', 'Создана', 'Дата завершения', 'Статус'
    Содержит: ключи 'Создана' 'Дата завершения', цикл перебора словаря note
    Механизм: функция получает дату создания и дату завершения из итерации цикла перебора
    БД (на данный момент это список словарей) и сравнивает их, получая объект timedelta,
    а затем выводит его результат, при помощи блока условий. Другой цикл функции
    перебирает ключи и значения словаря с выводом через функцию print
    """
    # Получение временной (temp) текущей даты для вычисления объекта timedelta
    temp_created_date = datetime.datetime.strptime(note['Создана'], "%d-%m-%Y")
    temp_issue_date = datetime.datetime.strptime(note['Дата завершения'], "%d-%m-%Y")
    # Визуальный разделитель
    print('⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯⋯')
    # Счетчик итератора, расположенного вне функции
    print(y + f'Заметка {iteration + 1}')
    # Перебор словаря note
    for key, value in note.items():
        # Соответствие типу данных list (для корректного вывода тем)
        if type(value) == list:
            print('▶ Тема: ', *value, sep=' |✎')
        # Вывод всех остальных типов данных
        else:
            print(f'▶ {key}: {value}')

        # Сравнение (temp) текущей даты и даты завершения deadline_var представляет собой объект timedelta
    if temp_created_date < temp_issue_date:
        deadline_var = temp_issue_date - temp_created_date
        print(lg + "↪ Осталось {} дней".format(deadline_var.days))
    elif temp_created_date > temp_issue_date:
        deadline_var = temp_created_date - temp_issue_date
        print(r + "↪ Просрочено на {} дней".format(deadline_var.days))
    else:
        print(r + '↪ Истекает сегодня')

# Список словарей с предустановленными заметками
notes_lst = [{'Имя пользователя': 'Влад',
              'Темы': ['Тестовый заголовок 1 в заметке Влада', 'Тестовый заголовок 2 в заметке Влада'],
              'Описание': 'Тестовое описание-1 в заметке влада',
              'Создана': '15-12-2024',
              'Дата завершения': '15-12-2024'
              },
             {'Имя пользователя': 'Елена',
              'Темы': ['Тестовый заголовок 1 в заметке Елены'],
              'Описание': 'Тестовое описание-2 в заметке Елены',
              'Создана': '15-12-2024',
              'Дата завершения': '10-01-2025'
              },
             {'Имя пользователя': 'Павел',
              'Темы': ['Тестовый заголовок 3 в заметке Павла'],
              'Описание': 'Тестовое описание-3 в заметке Павла',
              'Создана': '15-12-2024',
              'Дата завершения': '02-01-2025'
              },
             {'Имя пользователя': 'Зульфия',
              'Темы': ['Тестовый заголовок 4 в заметки Зульфии'],
              'Описание': 'Тестовое описание-4 в заметке Зульфии',
              'Создана': '15-12-2024',
              'Дата завершения': '01-01-1996'
              }
             ]

print(g+'* * ВАС ПРИВЕТСТВУЕТ МЕНЕДЖЕР ЗАМЕТОК 1.2.5 * *')

#___________ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ____________
while True:
    # Командное меню
    print(c + '\nВыберите команду, соответствующую пункту меню:'
              '\n○ Добавить новую заметку  — 1 '
              '\n○ Показать список заметок — 2 '
              '\n○ Редактировать заметку   — 3 '
              '\n○ Удалить заметку         — 4 '
              '\n○ Завершить работу        — 5'
              '\n\nСООБЩЕНИЕ ДЛЯ ПРЕПОДАВАТЕЛЯ - 6')

    # Пользовательский ввод команды
    command_add = input(m + '\nВведите команду: ')

    # ____КОМАНДА 1______Добавление новой заметки
    if command_add == '1':
        # Объявляем словарь для добавления новой заметки в список заметок
        add_note_dict = {}

        print(y + '\nСОЗДАНИЕ НОВОЙ ЗАМЕТКИ')

        # Вызов функций добавления полей заметки
        add_name_loop()
        add_titles_loop()
        add_description_loop()
        date_mechanism_loop()
        add_status_loop()

        # Сохранение словаря (заметки) в список
        notes_lst.append(add_note_dict)

        # Сообщение об успешном действии
        print(y + '\nЗАМЕТКА СОХРАНЕНА')

        console_pause()

    # ____КОМАНДА 2______Показать список заметок
    elif command_add == '2':
        print(y + '\nОТОБРАЖЕНИЕ СПИСКА ЗАМЕТОК')
        if len(notes_lst) == 0:
            print(r+'\nСписок заметок пуст')
        for iteration, note in enumerate(notes_lst):
            print_notes_loop()

        console_pause()

    # ____КОМАНДА 3______Редактирование заметки
    elif command_add == '3':
        print(y + '\nРЕДАКТИРОВАНИЕ ЗАМЕТКИ')
        # ЦИКЛ ПОИСКА ЗАМЕТКИ
        while True:
            try:
                print(c + f'\nВведите номер заметки для внесения изменений. '
                          f'Доступные значения команды от 1 до {len(notes_lst)}')
                    # Пользовательский ввод номера заметки для редактирования
                note_change_command = int(input(m + '\nВведите команду: '))
                    # Проверка ввода
                if note_change_command < 1:
                    print(r + '(!) Такой заметки не существует')
                    continue
                elif note_change_command > len(notes_lst):
                    print(r + '(!) Такой заметки не существует')
                    continue
            except ValueError:
                print(r + '(!) Команда должна быть целым числом')
                continue
            else:

                # Извлечение заметки из списка по индексу (индекс = тикер - 1)
                add_note_dict = notes_lst.pop(note_change_command - 1)
                break
        # МЕНЮ КОМАНД ДЛЯ ВЫБОРА ПОЛЯ ДЛЯ РЕДАКТИРОВАНИЯ
        while True:
            print(c + '\nВыберите поле для редактирования. '
                      '\n○ Имя пользователя   — 1'
                      '\n○ Темы               — 2'
                      '\n○ Описание           — 3'
                      '\n○ Статус             — 4'
                      '\n○ Дата завершения    — 5'
                      '\n○ Изменить все поля  — 6')

            # Ввод команды
            key_changer = input(m + '\nВведите команду: ')
            #______КОМАНДА 1_________Изменение имени пользователя
            if key_changer == '1':
                add_name_loop()
                notes_lst.insert((note_change_command - 1), add_note_dict)
                print(lg + '\nИЗМЕНЕНИЯ СОХРАНЕНЫ')
                console_pause()
                break
            # ______КОМАНДА 2_________Изменение тем
            elif key_changer == '2':
                add_titles_loop()
                notes_lst.insert((note_change_command - 1), add_note_dict)
                print(lg + '\nИЗМЕНЕНИЯ СОХРАНЕНЫ')
                console_pause()
                break
            # ______КОМАНДА 3_________Изменение описания
            elif key_changer == '3':
                add_description_loop()
                notes_lst.insert((note_change_command - 1), add_note_dict)
                print(lg + '\nИЗМЕНЕНИЯ СОХРАНЕНЫ')
                console_pause()
                break
            # ______КОМАНДА 4_________Изменение статуса
            elif key_changer == '4':
                add_status_loop()
                notes_lst.insert((note_change_command - 1), add_note_dict)
                print(lg + '\nИЗМЕНЕНИЯ СОХРАНЕНЫ')
                console_pause()
                break
            # ______КОМАНДА 5_________Изменение даты
            elif key_changer == '5':
                date_mechanism_loop()
                notes_lst.insert((note_change_command - 1), add_note_dict)
                print(lg + '\nИЗМЕНЕНИЯ СОХРАНЕНЫ')
                console_pause()
                break
            # ______КОМАНДА 2_________Изменение всех полей
            elif key_changer == '6':
                add_name_loop()
                add_titles_loop()
                add_description_loop()
                date_mechanism_loop()
                add_status_loop()
                notes_lst.insert((note_change_command - 1), add_note_dict)
                print(lg + '\nИЗМЕНЕНИЯ СОХРАНЕНЫ')
                console_pause()
                break
            else:
                print(r + '\n(!) Такой команды не существует! Пожалуйста, введите доступную команду.')
                continue

    # ____КОМАНДА 4______Удаление заметки
    elif command_add == '4':
        print(y + '\nУДАЛЕНИЕ ЗАМЕТКИ')
        while True:
            print(c + '\nВыберите критерий поиска:'
                      '\n○ По имени пользователя    — 1'
                      '\n○ По теме заметки          — 2'
                      '\n○ По номеру заметки        — 3')
            # Пользовательский ввод команды
            how_search = input(m + '\nВведите команду: ')

                # _______Команда 1__________Поиск по имени пользователя
            if how_search == '1':
                    # Ввод поисковой фразы
                search_inp = input(m + '\nВведите имя пользователя для поиска: ')
                del_notes_lst = notes_lst.copy()                    # Копия листа с заметками
                name_del_notes = 0                                  # Переменная - счётчик удалённых заметок
                    # Цикл поиска и сравнения введённой фразы по копии листа
                for iteration, note in enumerate(del_notes_lst):
                        # Получение value ключа в переменную
                    value_dict = note.get('Имя пользователя')
                        # Сравнение переменной с поисковой фразой с переводом в нижний регистр
                    if value_dict.lower() == search_inp.lower():
                        notes_lst.remove(note)                      # если True, то удаление всей заметки
                        name_del_notes += 1                         # +1 к переменной счётчику
                 # Блок условий для вывода результата работы команды
                if name_del_notes != 0:
                    print(lg + f'Заметки, содержащие «Имя пользователя: {search_inp}» удалены ({name_del_notes})')
                else:
                    print(r + f'Заметок, содержащих «Имя пользователя: {search_inp}» не найдено')
                console_pause()
                break

                # _______Команда 2__________Поиск по темам
            elif how_search == '2':
                """По аналогии с предыдущим блоком (отличия подписаны)"""
                search_inp = input(m + 'Введите тему для поиска: ')
                del_notes_lst = notes_lst.copy()
                name_del_notes = 0
                for iteration, note in enumerate(del_notes_lst):
                    value_dict = note.get('Темы')
                     # Выражение генератор для поиска и сравнения совпадений в списке тем ключа 'Темы'
                    if search_inp.lower() in (item.lower() for item in value_dict):
                        notes_lst.remove(note)
                        name_del_notes += 1
                if name_del_notes != 0:
                    print(lg + f'Заметки, содержащие «Тему: {search_inp}» удалены ({name_del_notes})')
                else:
                    print(r + f'Заметок, содержащих «Тему: {search_inp}» не найдено')
                console_pause()
                break
            # _______Команда 3__________По номеру заметки
            elif how_search == '3':
                while True:
                    try:
                            # Предлагаем пользователю диапазон номеров заметок
                        print(c + f'Введите номер заметки для внесения изменений. '
                                  f'Доступные значения команды от 0 до {len(notes_lst)}')
                            # Получение команды от пользователя
                        note_change_command = int(input(m + '\nВведите команду: '))
                            # Блок проверки пользовательского ввода
                        if note_change_command < 1:
                            print(r + '(!) Такой заметки не существует')
                            continue
                        elif note_change_command > len(notes_lst):
                            print(r + '(!) Такой заметки не существует')
                            continue
                    except ValueError:
                        print(r + '(!) Команда должна быть целым числом')
                        continue
                        # Удаление заметки (номер заметки - 1) и двойной обрыв while
                    else:
                        break_flag = True
                        del notes_lst[(note_change_command - 1)]
                        print(lg + f'Заметка {note_change_command} успешно удалена!')
                        console_pause()
                        break
                if break_flag == True:
                    break
            else:
                print(r + '\n(!) Такой команды не существует! Пожалуйста, введите доступную команду.')
                continue
    # ____КОМАНДА 5______Выход из программы
    elif command_add == '5':
        pass
        break
    elif command_add == '6':
        print('Здравствуйте, я очень понимаю, что почти 500 строк кода тяжело проверять!\n'
              '10 раз пожалел, что задал себе определённую планку в решении этого этапа.\n'
              'Уж очень хотелось получить цельный и последовательный результат, ну и облегчить\n'
              'себе дальнейшее прохождение Грейда.\n'
              'Под конец мне начало казаться, что программа уже полностью состоит из костылей.\n'
              'Если есть такая возможность, то в Вашем ответе, кроме прочего, хотелось бы получить примерную оценку\n'
              'закостыленности кода в % и отметить самые яркие костыли. Мне это очень поможет, спасибо!')

        console_pause()
        continue

    else:
        print(r + '\n(!) Такой команды не существует! Пожалуйста, введите доступную команду.')
        continue
